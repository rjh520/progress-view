"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAvailableBundleIds = getAvailableBundleIds;
exports.parseContainerPath = parseContainerPath;
exports.default = exports.commands = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _appiumSupport = require("appium-support");

var _path = _interopRequireDefault(require("path"));

var _appiumIosDriver = require("appium-ios-driver");

var _logger = _interopRequireDefault(require("../logger"));

var _teen_process = require("teen_process");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumIosDevice = require("appium-ios-device");

const CONTAINER_PATH_MARKER = '@';
const CONTAINER_PATH_PATTERN = new RegExp(`^${CONTAINER_PATH_MARKER}([^/]+)/(.*)`);
const CONTAINER_TYPE_SEPARATOR = ':';
const IFUSE_CONTAINER_DOCUMENTS = 'documents';
const CONTAINER_DOCUMENTS_PATH = 'Documents';
const IO_TIMEOUT = 60000;
const OBJECT_NOT_FOUND_ERROR_MESSAGE = 'OBJECT_NOT_FOUND';
const MAX_PULL_CHUNK_SIZE = 5;
let commands = _appiumIosDriver.iosCommands.file;
exports.commands = commands;

function verifyIsSubPath(originalPath, root) {
  const normalizedRoot = _path.default.normalize(root);

  const normalizedPath = _path.default.normalize(_path.default.dirname(originalPath));

  if (normalizedRoot !== originalPath && !normalizedPath.startsWith(normalizedRoot)) {
    _logger.default.errorAndThrow(`'${normalizedPath}' is expected to be a subpath of '${normalizedRoot}'`);
  }
}

async function createAfcClient(udid, bundleId, containerType) {
  if (!bundleId) {
    return await _appiumIosDevice.services.startAfcService(udid);
  }

  const service = await _appiumIosDevice.services.startHouseArrestService(udid);

  if (isDocuments(containerType)) {
    return await service.vendDocuments(bundleId);
  } else {
    return await service.vendContainer(bundleId);
  }
}

function isDocuments(containerType) {
  return _lodash.default.toLower(containerType) === IFUSE_CONTAINER_DOCUMENTS;
}

async function mkdirpDevice(service, dir) {
  if (dir === '.' || dir === '/') {
    return;
  }

  try {
    await service.listDirectory(dir);
    return;
  } catch (e) {
    await mkdirpDevice(service, _path.default.dirname(dir));
  }

  await service.createDirectory(dir);
}

async function createService(udid, remotePath) {
  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer,
      containerType
    } = await parseContainerPath(remotePath);
    const service = await createAfcClient(udid, bundleId, containerType);
    const relativePath = isDocuments(containerType) ? _path.default.join(CONTAINER_DOCUMENTS_PATH, pathInContainer) : pathInContainer;
    return {
      service,
      relativePath
    };
  } else {
    const service = await createAfcClient(udid);
    const relativePath = remotePath;
    return {
      service,
      relativePath
    };
  }
}

async function pullFileFromRealDevice(service, relativePath) {
  const stream = await service.createReadStream(relativePath, {
    autoDestroy: true
  });
  const pullPromise = new _bluebird.default((resolve, reject) => {
    stream.on('close', resolve);
    stream.on('error', reject);
  });
  const buffer = [];
  stream.on('data', data => buffer.push(data));

  try {
    await pullPromise.timeout(IO_TIMEOUT);
  } catch (e) {
    throw new Error(`Couldn't pull the file '${relativePath}' ` + `within the given timeout ${IO_TIMEOUT}ms. Original error: ${e.message}`);
  }

  return Buffer.concat(buffer).toString('base64');
}

async function pullFolderFromRealDevice(service, relativePath) {
  const tmpFolder = await _appiumSupport.tempDir.openDir();

  try {
    const folderPath = _path.default.join(tmpFolder, relativePath);

    await (0, _appiumSupport.mkdirp)(folderPath);
    const pullPromises = [];

    const waitForPullChunks = async () => {
      if (_lodash.default.isEmpty(pullPromises)) {
        return;
      }

      try {
        await _bluebird.default.all(pullPromises).timeout(IO_TIMEOUT);
      } catch (e) {
        throw new Error(`Couldn't pull all items in the folder '${relativePath}' ` + `within the given timeout ${IO_TIMEOUT}ms. Original error: ${e.message}`);
      }
    };

    await service.walkDir(relativePath, true, async (itemPath, isDir) => {
      const pathOnServer = _path.default.join(tmpFolder, itemPath);

      if (isDir) {
        await _appiumSupport.fs.mkdir(pathOnServer);
        return;
      }

      const readStream = await service.createReadStream(itemPath, {
        autoDestroy: true
      });

      const writeStream = _appiumSupport.fs.createWriteStream(pathOnServer, {
        autoClose: true
      });

      pullPromises.push(new _bluebird.default((resolve, reject) => {
        writeStream.on('close', resolve);

        const onStreamingError = e => {
          readStream.unpipe(writeStream);
          reject(e);
        };

        writeStream.on('error', onStreamingError);
        readStream.on('error', onStreamingError);
      }));
      readStream.pipe(writeStream);

      if (pullPromises.length % MAX_PULL_CHUNK_SIZE === 0) {
        await waitForPullChunks();
      }
    });
    await waitForPullChunks();
    return Buffer.from((await _appiumSupport.zip.toInMemoryZip(folderPath))).toString('base64');
  } finally {
    await _appiumSupport.fs.rimraf(tmpFolder);
  }
}

async function parseContainerPath(remotePath, containerRootSupplier) {
  const match = CONTAINER_PATH_PATTERN.exec(remotePath);

  if (!match) {
    _logger.default.errorAndThrow(`It is expected that package identifier ` + `starts with '${CONTAINER_PATH_MARKER}' and is separated from the ` + `relative path with a single slash. '${remotePath}' is given instead`);
  }

  let [, bundleId, relativePath] = match;
  let containerType = null;
  const typeSeparatorPos = bundleId.indexOf(CONTAINER_TYPE_SEPARATOR);

  if (typeSeparatorPos > 0 && typeSeparatorPos < bundleId.length - 1) {
    containerType = bundleId.substring(typeSeparatorPos + 1);

    _logger.default.debug(`Parsed container type: ${containerType}`);

    bundleId = bundleId.substring(0, typeSeparatorPos);
  }

  if (_lodash.default.isNil(containerRootSupplier)) {
    const pathInContainer = relativePath;
    return {
      bundleId,
      pathInContainer,
      containerType
    };
  }

  const containerRoot = _lodash.default.isFunction(containerRootSupplier) ? await containerRootSupplier(bundleId, containerType) : containerRootSupplier;

  const pathInContainer = _path.default.posix.resolve(containerRoot, relativePath);

  verifyIsSubPath(pathInContainer, containerRoot);
  return {
    bundleId,
    pathInContainer,
    containerType
  };
}

async function pushFileToSimulator(device, remotePath, base64Data) {
  const buffer = Buffer.from(base64Data, 'base64');

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will put the data into '${dstPath}'`);

    if (!(await _appiumSupport.fs.exists(_path.default.dirname(dstPath)))) {
      _logger.default.debug(`The destination folder '${_path.default.dirname(dstPath)}' does not exist. Creating...`);

      await (0, _appiumSupport.mkdirp)(_path.default.dirname(dstPath));
    }

    await _appiumSupport.fs.writeFile(dstPath, buffer);
    return;
  }

  const dstFolder = await _appiumSupport.tempDir.openDir();

  const dstPath = _path.default.resolve(dstFolder, _path.default.basename(remotePath));

  try {
    await _appiumSupport.fs.writeFile(dstPath, buffer);
    await device.simctl.addMedia(dstPath);
  } finally {
    await _appiumSupport.fs.rimraf(dstFolder);
  }
}

async function pushFileToRealDevice(device, remotePath, base64Data) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    await mkdirpDevice(service, _path.default.dirname(relativePath));
    const stream = await service.createWriteStream(relativePath, {
      autoDestroy: true
    });
    let pushError = null;
    const pushPromise = new _bluebird.default((resolve, reject) => {
      stream.on('error', e => {
        pushError = e;
      });
      stream.on('close', () => {
        if (pushError) {
          reject(pushError);
        } else {
          resolve();
        }
      });
    });
    stream.write(Buffer.from(base64Data, 'base64'));
    stream.end();

    try {
      await pushPromise.timeout(IO_TIMEOUT);
    } catch (e) {
      throw new Error(`Could not push the file within the given timeout ${IO_TIMEOUT}ms. ` + `Original error: ${e.message}`);
    }
  } finally {
    service.close();
  }
}

async function pullFromSimulator(device, remotePath, isFile) {
  let pathOnServer;

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will get the data from '${dstPath}'`);

    pathOnServer = dstPath;
  } else {
    const simRoot = device.getDir();
    pathOnServer = _path.default.posix.join(simRoot, remotePath);
    verifyIsSubPath(pathOnServer, simRoot);

    _logger.default.info(`Got the full item path: ${pathOnServer}`);
  }

  if (!(await _appiumSupport.fs.exists(pathOnServer))) {
    _logger.default.errorAndThrow(`The remote ${isFile ? 'file' : 'folder'} at '${pathOnServer}' does not exist`);
  }

  const buffer = isFile ? await _appiumSupport.fs.readFile(pathOnServer) : await _appiumSupport.zip.toInMemoryZip(pathOnServer);
  return Buffer.from(buffer).toString('base64');
}

async function pullFromRealDevice(device, remotePath, isFile) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    const fileInfo = await service.getFileInfo(relativePath);

    if (isFile && fileInfo.isDirectory()) {
      throw new Error(`The requested path is not a file. Path: '${remotePath}'`);
    }

    if (!isFile && !fileInfo.isDirectory()) {
      throw new Error(`The requested path is not a folder. Path: '${remotePath}'`);
    }

    if (fileInfo.isFile()) {
      return await pullFileFromRealDevice(service, relativePath);
    } else {
      return await pullFolderFromRealDevice(service, relativePath);
    }
  } catch (e) {
    if (e.message.includes(OBJECT_NOT_FOUND_ERROR_MESSAGE)) {
      throw new Error(`Path '${remotePath}' does not exist on the device`);
    }

    throw e;
  } finally {
    service.close();
  }
}

async function deleteFromSimulator(device, remotePath) {
  let pathOnServer;

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `'${dstPath}' will be deleted`);

    pathOnServer = dstPath;
  } else {
    const simRoot = device.getDir();
    pathOnServer = _path.default.posix.join(simRoot, remotePath);
    verifyIsSubPath(pathOnServer, simRoot);

    _logger.default.info(`Got the full path: ${pathOnServer}`);
  }

  if (!(await _appiumSupport.fs.exists(pathOnServer))) {
    _logger.default.errorAndThrow(`The remote path at '${pathOnServer}' does not exist`);
  }

  await _appiumSupport.fs.rimraf(pathOnServer);
}

async function deleteFromRealDevice(device, remotePath) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    await service.deleteDirectory(relativePath);
  } catch (e) {
    if (e.message.includes(OBJECT_NOT_FOUND_ERROR_MESSAGE)) {
      throw new Error(`Path '${remotePath}' does not exist on the device`);
    }

    throw e;
  } finally {
    service.close();
  }
}

async function getAvailableBundleIds(udid) {
  const service = await _appiumIosDevice.services.startInstallationProxyService(udid);

  try {
    const applications = await service.listApplications({
      applicationType: 'User'
    });
    const bundleIds = [];

    for (const [key, value] of Object.entries(applications)) {
      if (!value.UIFileSharingEnabled) {
        continue;
      }

      bundleIds.push(key);
    }

    return bundleIds;
  } finally {
    service.close();
  }
}

commands.pushFile = async function pushFile(remotePath, base64Data) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  if (_lodash.default.isArray(base64Data)) {
    base64Data = Buffer.from(base64Data).toString('utf8');
  }

  return this.isSimulator() ? await pushFileToSimulator(this.opts.device, remotePath, base64Data) : await pushFileToRealDevice(this.opts.device, remotePath, base64Data);
};

commands.pullFile = async function pullFile(remotePath) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, true) : await pullFromRealDevice(this.opts.device, remotePath, true);
};

async function deleteFileOrFolder(device, remotePath, isSimulator) {
  return isSimulator ? await deleteFromSimulator(device, remotePath) : await deleteFromRealDevice(device, remotePath);
}

commands.mobileDeleteFolder = async function mobileDeleteFolder(opts = {}) {
  let {
    remotePath
  } = opts;

  if (!remotePath.endsWith('/')) {
    remotePath = `${remotePath}/`;
  }

  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());
};

commands.mobileDeleteFile = async function mobileDeleteFile(opts = {}) {
  const {
    remotePath
  } = opts;

  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());
};

commands.getSimFileFullPath = async function getSimFileFullPath(remotePath) {
  let basePath = this.opts.device.getDir();
  let appName = null;

  if (this.opts.app) {
    let appNameRegex = new RegExp(`\\${_path.default.sep}([\\w-]+\\.app)`);
    let appNameMatches = appNameRegex.exec(this.opts.app);

    if (appNameMatches) {
      appName = appNameMatches[1];
    }
  }

  if (_appiumSupport.system.isWindows()) {
    if (remotePath.indexof('://') === 1) {
      remotePath = remotePath.slice(4);
    }
  } else {
    if (remotePath.indexOf('/') === 0) {
      remotePath = remotePath.slice(1);
    }
  }

  if (remotePath.startsWith(appName)) {
    let findPath = basePath;

    if (!this.opts.platformVersion || _appiumSupport.util.compareVersions(this.opts.platformVersion, '>=', '8.0')) {
      findPath = _path.default.resolve(basePath, 'Containers', 'Bundle');
    }

    findPath = findPath.replace(/\s/g, '\\ ');
    let {
      stdout
    } = await (0, _teen_process.exec)('find', [findPath, '-name', appName]);
    let appRoot = stdout.replace(/\n$/, '');
    let subPath = remotePath.substring(appName.length + 1);

    let fullPath = _path.default.resolve(appRoot, subPath);

    _logger.default.debug(`Finding app-relative file: '${fullPath}'`);

    return fullPath;
  }

  let fullPath = _path.default.resolve(basePath, remotePath);

  _logger.default.debug(`Finding sim-relative file: ${fullPath}`);

  return fullPath;
};

commands.pullFolder = async function pullFolder(remotePath) {
  if (!remotePath.endsWith('/')) {
    remotePath = `${remotePath}/`;
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, false) : await pullFromRealDevice(this.opts.device, remotePath, false);
};

var _default = commands;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9maWxlLW1vdmVtZW50LmpzIl0sIm5hbWVzIjpbIkNPTlRBSU5FUl9QQVRIX01BUktFUiIsIkNPTlRBSU5FUl9QQVRIX1BBVFRFUk4iLCJSZWdFeHAiLCJDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IiLCJJRlVTRV9DT05UQUlORVJfRE9DVU1FTlRTIiwiQ09OVEFJTkVSX0RPQ1VNRU5UU19QQVRIIiwiSU9fVElNRU9VVCIsIk9CSkVDVF9OT1RfRk9VTkRfRVJST1JfTUVTU0FHRSIsIk1BWF9QVUxMX0NIVU5LX1NJWkUiLCJjb21tYW5kcyIsImlvc0NvbW1hbmRzIiwiZmlsZSIsInZlcmlmeUlzU3ViUGF0aCIsIm9yaWdpbmFsUGF0aCIsInJvb3QiLCJub3JtYWxpemVkUm9vdCIsInBhdGgiLCJub3JtYWxpemUiLCJub3JtYWxpemVkUGF0aCIsImRpcm5hbWUiLCJzdGFydHNXaXRoIiwibG9nIiwiZXJyb3JBbmRUaHJvdyIsImNyZWF0ZUFmY0NsaWVudCIsInVkaWQiLCJidW5kbGVJZCIsImNvbnRhaW5lclR5cGUiLCJzZXJ2aWNlcyIsInN0YXJ0QWZjU2VydmljZSIsInNlcnZpY2UiLCJzdGFydEhvdXNlQXJyZXN0U2VydmljZSIsImlzRG9jdW1lbnRzIiwidmVuZERvY3VtZW50cyIsInZlbmRDb250YWluZXIiLCJfIiwidG9Mb3dlciIsIm1rZGlycERldmljZSIsImRpciIsImxpc3REaXJlY3RvcnkiLCJlIiwiY3JlYXRlRGlyZWN0b3J5IiwiY3JlYXRlU2VydmljZSIsInJlbW90ZVBhdGgiLCJ0ZXN0IiwicGF0aEluQ29udGFpbmVyIiwicGFyc2VDb250YWluZXJQYXRoIiwicmVsYXRpdmVQYXRoIiwiam9pbiIsInB1bGxGaWxlRnJvbVJlYWxEZXZpY2UiLCJzdHJlYW0iLCJjcmVhdGVSZWFkU3RyZWFtIiwiYXV0b0Rlc3Ryb3kiLCJwdWxsUHJvbWlzZSIsIkIiLCJyZXNvbHZlIiwicmVqZWN0Iiwib24iLCJidWZmZXIiLCJkYXRhIiwicHVzaCIsInRpbWVvdXQiLCJFcnJvciIsIm1lc3NhZ2UiLCJCdWZmZXIiLCJjb25jYXQiLCJ0b1N0cmluZyIsInB1bGxGb2xkZXJGcm9tUmVhbERldmljZSIsInRtcEZvbGRlciIsInRlbXBEaXIiLCJvcGVuRGlyIiwiZm9sZGVyUGF0aCIsInB1bGxQcm9taXNlcyIsIndhaXRGb3JQdWxsQ2h1bmtzIiwiaXNFbXB0eSIsImFsbCIsIndhbGtEaXIiLCJpdGVtUGF0aCIsImlzRGlyIiwicGF0aE9uU2VydmVyIiwiZnMiLCJta2RpciIsInJlYWRTdHJlYW0iLCJ3cml0ZVN0cmVhbSIsImNyZWF0ZVdyaXRlU3RyZWFtIiwiYXV0b0Nsb3NlIiwib25TdHJlYW1pbmdFcnJvciIsInVucGlwZSIsInBpcGUiLCJsZW5ndGgiLCJmcm9tIiwiemlwIiwidG9Jbk1lbW9yeVppcCIsInJpbXJhZiIsImNvbnRhaW5lclJvb3RTdXBwbGllciIsIm1hdGNoIiwiZXhlYyIsInR5cGVTZXBhcmF0b3JQb3MiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwiZGVidWciLCJpc05pbCIsImNvbnRhaW5lclJvb3QiLCJpc0Z1bmN0aW9uIiwicG9zaXgiLCJwdXNoRmlsZVRvU2ltdWxhdG9yIiwiZGV2aWNlIiwiYmFzZTY0RGF0YSIsImRzdFBhdGgiLCJhcHBCdW5kbGUiLCJzaW1jdGwiLCJnZXRBcHBDb250YWluZXIiLCJpbmZvIiwiZXhpc3RzIiwid3JpdGVGaWxlIiwiZHN0Rm9sZGVyIiwiYmFzZW5hbWUiLCJhZGRNZWRpYSIsInB1c2hGaWxlVG9SZWFsRGV2aWNlIiwicHVzaEVycm9yIiwicHVzaFByb21pc2UiLCJ3cml0ZSIsImVuZCIsImNsb3NlIiwicHVsbEZyb21TaW11bGF0b3IiLCJpc0ZpbGUiLCJzaW1Sb290IiwiZ2V0RGlyIiwicmVhZEZpbGUiLCJwdWxsRnJvbVJlYWxEZXZpY2UiLCJmaWxlSW5mbyIsImdldEZpbGVJbmZvIiwiaXNEaXJlY3RvcnkiLCJpbmNsdWRlcyIsImRlbGV0ZUZyb21TaW11bGF0b3IiLCJkZWxldGVGcm9tUmVhbERldmljZSIsImRlbGV0ZURpcmVjdG9yeSIsImdldEF2YWlsYWJsZUJ1bmRsZUlkcyIsInN0YXJ0SW5zdGFsbGF0aW9uUHJveHlTZXJ2aWNlIiwiYXBwbGljYXRpb25zIiwibGlzdEFwcGxpY2F0aW9ucyIsImFwcGxpY2F0aW9uVHlwZSIsImJ1bmRsZUlkcyIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsIlVJRmlsZVNoYXJpbmdFbmFibGVkIiwicHVzaEZpbGUiLCJlbmRzV2l0aCIsImlzQXJyYXkiLCJpc1NpbXVsYXRvciIsIm9wdHMiLCJwdWxsRmlsZSIsImRlbGV0ZUZpbGVPckZvbGRlciIsIm1vYmlsZURlbGV0ZUZvbGRlciIsIm1vYmlsZURlbGV0ZUZpbGUiLCJnZXRTaW1GaWxlRnVsbFBhdGgiLCJiYXNlUGF0aCIsImFwcE5hbWUiLCJhcHAiLCJhcHBOYW1lUmVnZXgiLCJzZXAiLCJhcHBOYW1lTWF0Y2hlcyIsInN5c3RlbSIsImlzV2luZG93cyIsImluZGV4b2YiLCJzbGljZSIsImZpbmRQYXRoIiwicGxhdGZvcm1WZXJzaW9uIiwidXRpbCIsImNvbXBhcmVWZXJzaW9ucyIsInJlcGxhY2UiLCJzdGRvdXQiLCJhcHBSb290Iiwic3ViUGF0aCIsImZ1bGxQYXRoIiwicHVsbEZvbGRlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBLE1BQU1BLHFCQUFxQixHQUFHLEdBQTlCO0FBRUEsTUFBTUMsc0JBQXNCLEdBQUcsSUFBSUMsTUFBSixDQUFZLElBQUdGLHFCQUFzQixjQUFyQyxDQUEvQjtBQUNBLE1BQU1HLHdCQUF3QixHQUFHLEdBQWpDO0FBQ0EsTUFBTUMseUJBQXlCLEdBQUcsV0FBbEM7QUFDQSxNQUFNQyx3QkFBd0IsR0FBRyxXQUFqQztBQUNBLE1BQU1DLFVBQVUsR0FBRyxLQUFuQjtBQUNBLE1BQU1DLDhCQUE4QixHQUFHLGtCQUF2QztBQUNBLE1B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QUcvSixjQUFLc0MsT0FBTCxDQUFhdUcsUUFBYixFQUF1Qm5ILFVBQXZCLENBQWY7O0FBQ0FyQixrQkFBSThFLEtBQUosQ0FBVyw4QkFBNkI0RSxRQUFTLEVBQWpEOztBQUNBLFNBQU9BLFFBQVA7QUFDRCxDQXpDRDs7QUEyQ0F0SyxRQUFRLENBQUN1SyxVQUFULEdBQXNCLGVBQWVBLFVBQWYsQ0FBMkJ0SSxVQUEzQixFQUF1QztBQUMzRCxNQUFJLENBQUNBLFVBQVUsQ0FBQzBHLFFBQVgsQ0FBb0IsR0FBcEIsQ0FBTCxFQUErQjtBQUM3QjFHLElBQUFBLFVBQVUsR0FBSSxHQUFFQSxVQUFXLEdBQTNCO0FBQ0Q7O0FBQ0QsU0FBTyxLQUFLNEcsV0FBTCxLQUNILE1BQU0zQixpQkFBaUIsQ0FBQyxLQUFLNEIsSUFBTCxDQUFVOUMsTUFBWCxFQUFtQi9ELFVBQW5CLEVBQStCLEtBQS9CLENBRHBCLEdBRUgsTUFBTXNGLGtCQUFrQixDQUFDLEtBQUt1QixJQUFMLENBQVU5QyxNQUFYLEVBQW1CL0QsVUFBbkIsRUFBK0IsS0FBL0IsQ0FGNUI7QUFHRCxDQVBEOztlQVdlakMsUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBzeXN0ZW0sIGZzLCB0ZW1wRGlyLCBta2RpcnAsIHppcCwgdXRpbCB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgaW9zQ29tbWFuZHMgfSBmcm9tICdhcHBpdW0taW9zLWRyaXZlcic7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IHNlcnZpY2VzIH0gZnJvbSAnYXBwaXVtLWlvcy1kZXZpY2UnO1xuXG5jb25zdCBDT05UQUlORVJfUEFUSF9NQVJLRVIgPSAnQCc7XG4vLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL1BMZEIwRy8yXG5jb25zdCBDT05UQUlORVJfUEFUSF9QQVRURVJOID0gbmV3IFJlZ0V4cChgXiR7Q09OVEFJTkVSX1BBVEhfTUFSS0VSfShbXi9dKykvKC4qKWApO1xuY29uc3QgQ09OVEFJTkVSX1RZUEVfU0VQQVJBVE9SID0gJzonO1xuY29uc3QgSUZVU0VfQ09OVEFJTkVSX0RPQ1VNRU5UUyA9ICdkb2N1bWVudHMnO1xuY29uc3QgQ09OVEFJTkVSX0RPQ1VNRU5UU19QQVRIID0gJ0RvY3VtZW50cyc7XG5jb25zdCBJT19USU1FT1VUID0gNjAwMDA7XG5jb25zdCBPQkpFQ1RfTk9UX0ZPVU5EX0VSUk9SX01FU1NBR0UgPSAnT0JKRUNUX05PVF9GT1VORCc7XG5jb25zdCBNQVhfUFVMTF9DSFVOS19TSVpFID0gNTtcblxubGV0IGNvbW1hbmRzID0gaW9zQ29tbWFuZHMuZmlsZTtcblxuZnVuY3Rpb24gdmVyaWZ5SXNTdWJQYXRoIChvcmlnaW5hbFBhdGgsIHJvb3QpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFJvb3QgPSBwYXRoLm5vcm1hbGl6ZShyb290KTtcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBwYXRoLm5vcm1hbGl6ZShwYXRoLmRpcm5hbWUob3JpZ2luYWxQYXRoKSk7XG4gIC8vIElmIG9yaWdpbmFsUGF0aCBpcyByb290LCBgL2AsIG9yaWdpbmFsUGF0aCBzaG91bGQgZXF1YWwgdG8gbm9ybWFsaXplZFJvb3RcbiAgaWYgKG5vcm1hbGl6ZWRSb290ICE9PSBvcmlnaW5hbFBhdGggJiYgIW5vcm1hbGl6ZWRQYXRoLnN0YXJ0c1dpdGgobm9ybWFsaXplZFJvb3QpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYCcke25vcm1hbGl6ZWRQYXRofScgaXMgZXhwZWN0ZWQgdG8gYmUgYSBzdWJwYXRoIG9mICcke25vcm1hbGl6ZWRSb290fSdgKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBZmNDbGllbnQgKHVkaWQsIGJ1bmRsZUlkLCBjb250YWluZXJUeXBlKSB7XG4gIGlmICghYnVuZGxlSWQpIHtcbiAgICByZXR1cm4gYXdhaXQgc2VydmljZXMuc3RhcnRBZmNTZXJ2aWNlKHVkaWQpO1xuICB9XG4gIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBzZXJ2aWNlcy5zdGFydEhvdXNlQXJyZXN0U2VydmljZSh1ZGlkKTtcbiAgaWYgKGlzRG9jdW1lbnRzKGNvbnRhaW5lclR5cGUpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHNlcnZpY2UudmVuZERvY3VtZW50cyhidW5kbGVJZCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF3YWl0IHNlcnZpY2UudmVuZENvbnRhaW5lcihidW5kbGVJZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNEb2N1bWVudHMgKGNvbnRhaW5lclR5cGUpIHtcbiAgcmV0dXJuIF8udG9Mb3dlcihjb250YWluZXJUeXBlKSA9PT0gSUZVU0VfQ09OVEFJTkVSX0RPQ1VNRU5UUztcbn1cblxuYXN5bmMgZnVuY3Rpb24gbWtkaXJwRGV2aWNlIChzZXJ2aWNlLCBkaXIpIHtcbiAgaWYgKGRpciA9PT0gJy4nIHx8IGRpciA9PT0gJy8nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgc2VydmljZS5saXN0RGlyZWN0b3J5KGRpcik7XG4gICAgcmV0dXJuO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVGhpcyBtZWFucyB0aGF0IHRoZSBkaXJlY3RvcnkgaXMgbWlzc2luZyBhbmQgd2UgZ290IGFuIG9iamVjdCBub3QgZm91bmQgZXJyb3IuIFRoZXJlZm9yZSwgd2UgYXJlIGdvaW5nIHRvIHRoZSBwYXJlbnRcbiAgICBhd2FpdCBta2RpcnBEZXZpY2Uoc2VydmljZSwgcGF0aC5kaXJuYW1lKGRpcikpO1xuICB9XG4gIGF3YWl0IHNlcnZpY2UuY3JlYXRlRGlyZWN0b3J5KGRpcik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNlcnZpY2UgKHVkaWQsIHJlbW90ZVBhdGgpIHtcbiAgaWYgKENPTlRBSU5FUl9QQVRIX1BBVFRFUk4udGVzdChyZW1vdGVQYXRoKSkge1xuICAgIGNvbnN0IHtidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyLCBjb250YWluZXJUeXBlfSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoKTtcbiAgICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgY3JlYXRlQWZjQ2xpZW50KHVkaWQsIGJ1bmRsZUlkLCBjb250YWluZXJUeXBlKTtcbiAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBpc0RvY3VtZW50cyhjb250YWluZXJUeXBlKSA/IHBhdGguam9pbihDT05UQUlORVJfRE9DVU1FTlRTX1BBVEgsIHBhdGhJbkNvbnRhaW5lcikgOiBwYXRoSW5Db250YWluZXI7XG4gICAgcmV0dXJuIHtzZXJ2aWNlLCByZWxhdGl2ZVBhdGh9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBjcmVhdGVBZmNDbGllbnQodWRpZCk7XG4gICAgY29uc3QgcmVsYXRpdmVQYXRoID0gcmVtb3RlUGF0aDtcbiAgICByZXR1cm4ge3NlcnZpY2UsIHJlbGF0aXZlUGF0aH07XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcHVsbEZpbGVGcm9tUmVhbERldmljZSAoc2VydmljZSwgcmVsYXRpdmVQYXRoKSB7XG4gIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHNlcnZpY2UuY3JlYXRlUmVhZFN0cmVhbShyZWxhdGl2ZVBhdGgsIHsgYXV0b0Rlc3Ryb3k6IHRydWUgfSk7XG4gIGNvbnN0IHB1bGxQcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHN0cmVhbS5vbignY2xvc2UnLCByZXNvbHZlKTtcbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgfSk7XG4gIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICBzdHJlYW0ub24oJ2RhdGEnLCAoZGF0YSkgPT4gYnVmZmVyLnB1c2goZGF0YSkpO1xuICB0cnkge1xuICAgIGF3YWl0IHB1bGxQcm9taXNlLnRpbWVvdXQoSU9fVElNRU9VVCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IHB1bGwgdGhlIGZpbGUgJyR7cmVsYXRpdmVQYXRofScgYCArXG4gICAgICBgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0ICR7SU9fVElNRU9VVH1tcy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmZlcikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBwdWxsRm9sZGVyRnJvbVJlYWxEZXZpY2UgKHNlcnZpY2UsIHJlbGF0aXZlUGF0aCkge1xuICBjb25zdCB0bXBGb2xkZXIgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb2xkZXJQYXRoID0gcGF0aC5qb2luKHRtcEZvbGRlciwgcmVsYXRpdmVQYXRoKTtcbiAgICBhd2FpdCBta2RpcnAoZm9sZGVyUGF0aCk7XG4gICAgY29uc3QgcHVsbFByb21pc2VzID0gW107XG4gICAgY29uc3Qgd2FpdEZvclB1bGxDaHVua3MgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoXy5pc0VtcHR5KHB1bGxQcm9taXNlcykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBCLmFsbChwdWxsUHJvbWlzZXMpLnRpbWVvdXQoSU9fVElNRU9VVCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgcHVsbCBhbGwgaXRlbXMgaW4gdGhlIGZvbGRlciAnJHtyZWxhdGl2ZVBhdGh9JyBgICtcbiAgICAgICAgICBgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0ICR7SU9fVElNRU9VVH1tcy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH07XG4gICAgYXdhaXQgc2VydmljZS53YWxrRGlyKHJlbGF0aXZlUGF0aCwgdHJ1ZSwgYXN5bmMgKGl0ZW1QYXRoLCBpc0RpcikgPT4ge1xuICAgICAgY29uc3QgcGF0aE9uU2VydmVyID0gcGF0aC5qb2luKHRtcEZvbGRlciwgaXRlbVBhdGgpO1xuICAgICAgaWYgKGlzRGlyKSB7XG4gICAgICAgIGF3YWl0IGZzLm1rZGlyKHBhdGhPblNlcnZlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhZFN0cmVhbSA9IGF3YWl0IHNlcnZpY2UuY3JlYXRlUmVhZFN0cmVhbShpdGVtUGF0aCwge2F1dG9EZXN0cm95OiB0cnVlfSk7XG4gICAgICBjb25zdCB3cml0ZVN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKHBhdGhPblNlcnZlciwge2F1dG9DbG9zZTogdHJ1ZX0pO1xuICAgICAgcHVsbFByb21pc2VzLnB1c2gobmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB3cml0ZVN0cmVhbS5vbignY2xvc2UnLCByZXNvbHZlKTtcbiAgICAgICAgY29uc3Qgb25TdHJlYW1pbmdFcnJvciA9IChlKSA9PiB7XG4gICAgICAgICAgcmVhZFN0cmVhbS51bnBpcGUod3JpdGVTdHJlYW0pO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfTtcbiAgICAgICAgd3JpdGVTdHJlYW0ub24oJ2Vycm9yJywgb25TdHJlYW1pbmdFcnJvcik7XG4gICAgICAgIHJlYWRTdHJlYW0ub24oJ2Vycm9yJywgb25TdHJlYW1pbmdFcnJvcik7XG4gICAgICB9KSk7XG4gICAgICByZWFkU3RyZWFtLnBpcGUod3JpdGVTdHJlYW0pO1xuICAgICAgaWYgKHB1bGxQcm9taXNlcy5sZW5ndGggJSBNQVhfUFVMTF9DSFVOS19TSVpFID09PSAwKSB7XG4gICAgICAgIGF3YWl0IHdhaXRGb3JQdWxsQ2h1bmtzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gV2FpdCBmb3IgdGhlIHJlc3Qgb2YgdGhlIGNodW5rc1xuICAgIGF3YWl0IHdhaXRGb3JQdWxsQ2h1bmtzKCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGF3YWl0IHppcC50b0luTWVtb3J5WmlwKGZvbGRlclBhdGgpKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKHRtcEZvbGRlcik7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb250YWluZXJPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYnVuZGxlSWQgLSBUaGUgcGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF0aEluQ29udGFpbmVyIC0gVGhlIGFic29sdXRlIGZ1bGwgcGF0aCBvZiB0aGUgaXRlbSBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW1cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gY29udGFpbmVyVHlwZSAtIFRoZSBjb250YWluZXIgdHlwZVxuICovXG5cbi8qKlxuICogUGFyc2VzIHRoZSBhY3R1YWwgcGF0aCBhbmQgdGhlIGJ1bmRsZSBpZGVudGlmaWVyIGZyb20gdGhlIGdpdmVuIHBhdGggc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgZ2l2ZW4gcGF0aCBzdHJpbmcuIFRoZSBzdHJpbmcgc2hvdWxkXG4gKiBtYXRjaCBgQ09OVEFJTkVSX1BBVEhfUEFUVEVSTmAgcmVnZXhwLCBvdGhlcndpc2UgYW4gZXJyb3IgaXMgZ29pbmdcbiAqIHRvIGJlIHRocm93bi4gQSB2YWxpZCBzdHJpbmcgZXhhbXBsZTogYEBidW5kbGUuaWRlbnRpZmllcjpjb250YWluZXJfdHlwZS9yZWxhdGl2ZV9wYXRoX2luX2NvbnRhaW5lcmBcbiAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBjb250YWluZXJSb290U3VwcGxpZXIgLSBFaXRoZXIgYSBzdHJpbmcsIHRoYXQgY29udGFpbnNcbiAqIGZ1bGwgcGF0aCB0byB0aGUgbW91bnQgcm9vdCBmb3IgcmVhbCBkZXZpY2VzIG9yIGEgZnVuY3Rpb24sIHdoaWNoIGFjY2VwdHMgdHdvIHBhcmFtZXRlcnNcbiAqIChidW5kbGUgaWRlbnRpZmllciBhbmQgb3B0aW9uYWwgY29udGFpbmVyIHR5cGUpIGFuZCByZXR1cm5zIGZ1bGwgcGF0aCB0byBjb250YWluZXJcbiAqIHJvb3QgZm9sZGVyIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbSwgZm9yIFNpbXVsYXRvclxuICogQHJldHVybnMge0NvbnRhaW5lck9iamVjdH1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VDb250YWluZXJQYXRoIChyZW1vdGVQYXRoLCBjb250YWluZXJSb290U3VwcGxpZXIpIHtcbiAgY29uc3QgbWF0Y2ggPSBDT05UQUlORVJfUEFUSF9QQVRURVJOLmV4ZWMocmVtb3RlUGF0aCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSXQgaXMgZXhwZWN0ZWQgdGhhdCBwYWNrYWdlIGlkZW50aWZpZXIgYCArXG4gICAgICBgc3RhcnRzIHdpdGggJyR7Q09OVEFJTkVSX1BBVEhfTUFSS0VSfScgYW5kIGlzIHNlcGFyYXRlZCBmcm9tIHRoZSBgICtcbiAgICAgIGByZWxhdGl2ZSBwYXRoIHdpdGggYSBzaW5nbGUgc2xhc2guICcke3JlbW90ZVBhdGh9JyBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgbGV0IFssIGJ1bmRsZUlkLCByZWxhdGl2ZVBhdGhdID0gbWF0Y2g7XG4gIGxldCBjb250YWluZXJUeXBlID0gbnVsbDtcbiAgY29uc3QgdHlwZVNlcGFyYXRvclBvcyA9IGJ1bmRsZUlkLmluZGV4T2YoQ09OVEFJTkVSX1RZUEVfU0VQQVJBVE9SKTtcbiAgLy8gV2Ugb25seSBjb25zaWRlciBjb250YWluZXIgdHlwZSBleGlzdHMgaWYgaXRzIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gemVyb1xuICAvLyBub3QgY291bnRpbmcgdGhlIGNvbG9uXG4gIGlmICh0eXBlU2VwYXJhdG9yUG9zID4gMCAmJiB0eXBlU2VwYXJhdG9yUG9zIDwgYnVuZGxlSWQubGVuZ3RoIC0gMSkge1xuICAgIGNvbnRhaW5lclR5cGUgPSBidW5kbGVJZC5zdWJzdHJpbmcodHlwZVNlcGFyYXRvclBvcyArIDEpO1xuICAgIGxvZy5kZWJ1ZyhgUGFyc2VkIGNvbnRhaW5lciB0eXBlOiAke2NvbnRhaW5lclR5cGV9YCk7XG4gICAgYnVuZGxlSWQgPSBidW5kbGVJZC5zdWJzdHJpbmcoMCwgdHlwZVNlcGFyYXRvclBvcyk7XG4gIH1cbiAgaWYgKF8uaXNOaWwoY29udGFpbmVyUm9vdFN1cHBsaWVyKSkge1xuICAgIGNvbnN0IHBhdGhJbkNvbnRhaW5lciA9IHJlbGF0aXZlUGF0aDtcbiAgICByZXR1cm4geyBidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyLCBjb250YWluZXJUeXBlIH07XG4gIH1cbiAgY29uc3QgY29udGFpbmVyUm9vdCA9IF8uaXNGdW5jdGlvbihjb250YWluZXJSb290U3VwcGxpZXIpXG4gICAgPyBhd2FpdCBjb250YWluZXJSb290U3VwcGxpZXIoYnVuZGxlSWQsIGNvbnRhaW5lclR5cGUpXG4gICAgOiBjb250YWluZXJSb290U3VwcGxpZXI7XG4gIGNvbnN0IHBhdGhJbkNvbnRhaW5lciA9IHBhdGgucG9zaXgucmVzb2x2ZShjb250YWluZXJSb290LCByZWxhdGl2ZVBhdGgpO1xuICB2ZXJpZnlJc1N1YlBhdGgocGF0aEluQ29udGFpbmVyLCBjb250YWluZXJSb290KTtcbiAgcmV0dXJuIHtidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyLCBjb250YWluZXJUeXBlfTtcbn1cblxuLyoqXG4gKiBTYXZlIHRoZSBnaXZlbiBiYXNlNjQgZGF0YSBjaHVuayBhcyBhIGJpbmFyeSBmaWxlIG9uIHRoZSBTaW11bGF0b3IgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIG9uIHRoZSBkZXZpY2UuIFRoaXMgdmFyaWFibGUgY2FuIGJlIHByZWZpeGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlIGlkLCBzbyB0aGVuIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLCBmb3IgZXhhbXBsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQGNvbS5teWFwcC5ibGE6ZGF0YS9SZWxhdGl2ZVBhdGhJbkNvbnRhaW5lci8xMTEucG5nJy4gVGhlICdAJyBjaGFyYWN0ZXIgYXQgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2lubmluZyBvZiB0aGUgYXJndW1lbnQgaXMgbWFuZGF0b3J5IGluIHN1Y2ggY2FzZS4gVGhlIGNvbG9uIGF0IHRoZSBlbmQgb2YgYnVuZGxlIGlkZW50aWZpZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgb3B0aW9uYWwgYW5kIGlzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggdGhlIGNvbnRhaW5lciB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3NzaWJsZSB2YWx1ZXMgdGhlcmUgYXJlICdhcHAnLCAnZGF0YScsICdncm91cHMnLCAnPEEgc3BlY2lmaWMgQXBwIEdyb3VwIGNvbnRhaW5lcj4nLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAnYXBwJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJlbGF0aXZlIGZvbGRlciBwYXRoIGlzIGlnbm9yZWQgaWYgdGhlIGZpbGUgaXMgZ29pbmcgdG8gYmUgdXBsb2FkZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyIGFuZCBvbmx5IHRoZSBmaWxlIG5hbWUgaXMgY29uc2lkZXJlZCBpbXBvcnRhbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0RGF0YSAtIEJhc2UtNjQgZW5jb2RlZCBjb250ZW50IG9mIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBwdXNoRmlsZVRvU2ltdWxhdG9yIChkZXZpY2UsIHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpIHtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYmFzZTY0RGF0YSwgJ2Jhc2U2NCcpO1xuICBpZiAoQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi50ZXN0KHJlbW90ZVBhdGgpKSB7XG4gICAgY29uc3Qge2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXI6IGRzdFBhdGh9ID0gYXdhaXQgcGFyc2VDb250YWluZXJQYXRoKHJlbW90ZVBhdGgsXG4gICAgICBhc3luYyAoYXBwQnVuZGxlLCBjb250YWluZXJUeXBlKSA9PiBhd2FpdCBkZXZpY2Uuc2ltY3RsLmdldEFwcENvbnRhaW5lcihhcHBCdW5kbGUsIGNvbnRhaW5lclR5cGUpKTtcbiAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgYFdpbGwgcHV0IHRoZSBkYXRhIGludG8gJyR7ZHN0UGF0aH0nYCk7XG4gICAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aC5kaXJuYW1lKGRzdFBhdGgpKSkge1xuICAgICAgbG9nLmRlYnVnKGBUaGUgZGVzdGluYXRpb24gZm9sZGVyICcke3BhdGguZGlybmFtZShkc3RQYXRoKX0nIGRvZXMgbm90IGV4aXN0LiBDcmVhdGluZy4uLmApO1xuICAgICAgYXdhaXQgbWtkaXJwKHBhdGguZGlybmFtZShkc3RQYXRoKSk7XG4gICAgfVxuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCBidWZmZXIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkc3RGb2xkZXIgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShkc3RGb2xkZXIsIHBhdGguYmFzZW5hbWUocmVtb3RlUGF0aCkpO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCBidWZmZXIpO1xuICAgIGF3YWl0IGRldmljZS5zaW1jdGwuYWRkTWVkaWEoZHN0UGF0aCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKGRzdEZvbGRlcik7XG4gIH1cbn1cblxuLyoqXG4gKiBTYXZlIHRoZSBnaXZlbiBiYXNlNjQgZGF0YSBjaHVuayBhcyBhIGJpbmFyeSBmaWxlIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIG9uIHRoZSBkZXZpY2UuIFRoaXMgdmFyaWFibGUgY2FuIGJlIHByZWZpeGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlIGlkLCBzbyB0aGVuIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLiBVc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPjo8b3B0aW9uYWxfY29udGFpbmVyX3R5cGU+LzxwYXRoX3RvX3RoZV9maWxlX29yX2ZvbGRlcl9pbnNpZGVfY29udGFpbmVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgdG8gcHVsbCBhIGZpbGUgb3IgYSBmb2xkZXIgZnJvbSBhbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvbmx5IHN1cHBvcnRlZCBjb250YWluZXIgdHlwZSBpcyAnZG9jdW1lbnRzJy4gSWYgdGhlIGNvbnRhaW5lciB0eXBlIGlzIG5vdCBzZXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwbGljaXRseSBmb3IgYSBidW5kbGUgaWQsIHRoZW4gdGhlIGRlZmF1bHQgYXBwbGljYXRpb24gY29udGFpbmVyIGlzIGdvaW5nIHRvIGJlIG1vdW50ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFrYSAtLWNvbnRhaW5lciBpZnVzZSBhcmd1bWVudClcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5nLiBJZiBgQGNvbS5teWFwcC5ibGE6ZG9jdW1lbnRzLzExMS5wbmdgIGlzIHByb3ZpZGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAgaW4gRmlsZXMgYXBwIHdpbGwgYmUgbW91bnRlZCBpbiB0aGUgaG9zdCBtYWNoaW5lLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJhc2U2NCBlbmNvZGVkIGAxMTEucG5nYCB3aWxsIGJlIHB1c2hlZCBpbnRvIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPi8xMTEucG5nYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIGJhc2U2NCBkZWNvZGVkIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0RGF0YSAtIEJhc2UtNjQgZW5jb2RlZCBjb250ZW50IG9mIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBwdXNoRmlsZVRvUmVhbERldmljZSAoZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKSB7XG4gIGNvbnN0IHtzZXJ2aWNlLCByZWxhdGl2ZVBhdGh9ID0gYXdhaXQgY3JlYXRlU2VydmljZShkZXZpY2UudWRpZCwgcmVtb3RlUGF0aCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgbWtkaXJwRGV2aWNlKHNlcnZpY2UsIHBhdGguZGlybmFtZShyZWxhdGl2ZVBhdGgpKTtcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBzZXJ2aWNlLmNyZWF0ZVdyaXRlU3RyZWFtKHJlbGF0aXZlUGF0aCwge2F1dG9EZXN0cm95OiB0cnVlfSk7XG4gICAgbGV0IHB1c2hFcnJvciA9IG51bGw7XG4gICAgY29uc3QgcHVzaFByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzdHJlYW0ub24oJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgICAgcHVzaEVycm9yID0gZTtcbiAgICAgIH0pO1xuICAgICAgc3RyZWFtLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgaWYgKHB1c2hFcnJvcikge1xuICAgICAgICAgIHJlamVjdChwdXNoRXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKGJhc2U2NERhdGEsICdiYXNlNjQnKSk7XG4gICAgc3RyZWFtLmVuZCgpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwdXNoUHJvbWlzZS50aW1lb3V0KElPX1RJTUVPVVQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHB1c2ggdGhlIGZpbGUgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0ICR7SU9fVElNRU9VVH1tcy4gYCArXG4gICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHNlcnZpY2UuY2xvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29udGVudCBvZiBnaXZlbiBmaWxlIG9yIGZvbGRlciBmcm9tIGlPUyBTaW11bGF0b3IgYW5kIHJldHVybiBpdCBhcyBiYXNlLTY0IGVuY29kZWQgc3RyaW5nLlxuICogRm9sZGVyIGNvbnRlbnQgaXMgcmVjdXJzaXZlbHkgcGFja2VkIGludG8gYSB6aXAgYXJjaGl2ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYSBmaWxlIG9yIGEgZm9sZGVyLCB3aGljaCBleGlzdHMgaW4gdGhlIGNvcnJlc3BvbmRpbmcgYXBwbGljYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyIG9uIFNpbXVsYXRvci4gVXNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEA8YXBwX2J1bmRsZV9pZD46PG9wdGlvbmFsX2NvbnRhaW5lcl90eXBlPi88cGF0aF90b190aGVfZmlsZV9vcl9mb2xkZXJfaW5zaWRlX2NvbnRhaW5lcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IHRvIHB1bGwgYSBmaWxlIG9yIGEgZm9sZGVyIGZyb20gYW4gYXBwbGljYXRpb24gY29udGFpbmVyIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3NzaWJsZSBjb250YWluZXIgdHlwZXMgYXJlICdhcHAnLCAnZGF0YScsICdncm91cHMnLCAnPEEgc3BlY2lmaWMgQXBwIEdyb3VwIGNvbnRhaW5lcj4nLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB0eXBlIGlzICdhcHAnLlxuICogQHBhcmFtIHtib29sZWFufSBpc0ZpbGUgLSBXaGV0aGVyIHRoZSBkZXN0aW5hdGlvbiBpdGVtIGlzIGEgZmlsZSBvciBhIGZvbGRlclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZS02NCBlbmNvZGVkIGNvbnRlbnQgb2YgdGhlIGZpbGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1bGxGcm9tU2ltdWxhdG9yIChkZXZpY2UsIHJlbW90ZVBhdGgsIGlzRmlsZSkge1xuICBsZXQgcGF0aE9uU2VydmVyO1xuICBpZiAoQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi50ZXN0KHJlbW90ZVBhdGgpKSB7XG4gICAgY29uc3Qge2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXI6IGRzdFBhdGh9ID0gYXdhaXQgcGFyc2VDb250YWluZXJQYXRoKHJlbW90ZVBhdGgsXG4gICAgICBhc3luYyAoYXBwQnVuZGxlLCBjb250YWluZXJUeXBlKSA9PiBhd2FpdCBkZXZpY2Uuc2ltY3RsLmdldEFwcENvbnRhaW5lcihhcHBCdW5kbGUsIGNvbnRhaW5lclR5cGUpKTtcbiAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgYFdpbGwgZ2V0IHRoZSBkYXRhIGZyb20gJyR7ZHN0UGF0aH0nYCk7XG4gICAgcGF0aE9uU2VydmVyID0gZHN0UGF0aDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzaW1Sb290ID0gZGV2aWNlLmdldERpcigpO1xuICAgIHBhdGhPblNlcnZlciA9IHBhdGgucG9zaXguam9pbihzaW1Sb290LCByZW1vdGVQYXRoKTtcbiAgICB2ZXJpZnlJc1N1YlBhdGgocGF0aE9uU2VydmVyLCBzaW1Sb290KTtcbiAgICBsb2cuaW5mbyhgR290IHRoZSBmdWxsIGl0ZW0gcGF0aDogJHtwYXRoT25TZXJ2ZXJ9YCk7XG4gIH1cbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aE9uU2VydmVyKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBUaGUgcmVtb3RlICR7aXNGaWxlID8gJ2ZpbGUnIDogJ2ZvbGRlcid9IGF0ICcke3BhdGhPblNlcnZlcn0nIGRvZXMgbm90IGV4aXN0YCk7XG4gIH1cbiAgY29uc3QgYnVmZmVyID0gaXNGaWxlXG4gICAgPyBhd2FpdCBmcy5yZWFkRmlsZShwYXRoT25TZXJ2ZXIpXG4gICAgOiBhd2FpdCB6aXAudG9Jbk1lbW9yeVppcChwYXRoT25TZXJ2ZXIpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZW50IG9mIGdpdmVuIGZpbGUgb3IgZm9sZGVyIGZyb20gdGhlIHJlYWwgZGV2aWNlIHVuZGVyIHRlc3QgYW5kIHJldHVybiBpdCBhcyBiYXNlLTY0IGVuY29kZWQgc3RyaW5nLlxuICogRm9sZGVyIGNvbnRlbnQgaXMgcmVjdXJzaXZlbHkgcGFja2VkIGludG8gYSB6aXAgYXJjaGl2ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYW4gZXhpc3RpbmcgcmVtb3RlIGZpbGUgb24gdGhlIGRldmljZS4gVGhpcyB2YXJpYWJsZSBjYW4gYmUgcHJlZml4ZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUgaWQsIHNvIHRoZW4gdGhlIGZpbGUgd2lsbCBiZSBkb3dubG9hZGVkIGZyb20gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLiBVc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPjo8b3B0aW9uYWxfY29udGFpbmVyX3R5cGU+LzxwYXRoX3RvX3RoZV9maWxlX29yX2ZvbGRlcl9pbnNpZGVfY29udGFpbmVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgdG8gcHVsbCBhIGZpbGUgb3IgYSBmb2xkZXIgZnJvbSBhbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvbmx5IHN1cHBvcnRlZCBjb250YWluZXIgdHlwZSBpcyAnZG9jdW1lbnRzJy4gSWYgdGhlIGNvbnRhaW5lciB0eXBlIGlzIG5vdCBzZXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwbGljaXRseSBmb3IgYSBidW5kbGUgaWQsIHRoZW4gdGhlIGRlZmF1bHQgYXBwbGljYXRpb24gY29udGFpbmVyIGlzIGdvaW5nIHRvIGJlIG1vdW50ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFrYSAtLWNvbnRhaW5lciBpZnVzZSBhcmd1bWVudClcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5nLiBJZiBgQGNvbS5teWFwcC5ibGE6ZG9jdW1lbnRzLzExMS5wbmdgIGlzIHByb3ZpZGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAgaW4gRmlsZXMgYXBwIHdpbGwgYmUgbW91bnRlZCBpbiB0aGUgaG9zdCBtYWNoaW5lLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPi8xMTEucG5nYCB3aWwgYmUgcHVsbGVkIGludG8gdGhlIG1vdW50ZWQgaG9zdCBtYWNoaW5lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIEFwcGl1bSByZXR1cm5zIHRoZSBkYXRhIGFzIGJhc2U2NC1lbmNvZGVkIHN0cmluZyB0byBjbGllbnQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEBjb20ubXlhcHAuYmxhOmRvY3VtZW50cy9gIG1lYW5zIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRmlsZSAtIFdoZXRoZXIgdGhlIGRlc3RpbmF0aW9uIGl0ZW0gaXMgYSBmaWxlIG9yIGEgZm9sZGVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2UtNjQgZW5jb2RlZCBjb250ZW50IG9mIHRoZSByZW1vdGUgZmlsZVxuICovXG5hc3luYyBmdW5jdGlvbiBwdWxsRnJvbVJlYWxEZXZpY2UgKGRldmljZSwgcmVtb3RlUGF0aCwgaXNGaWxlKSB7XG4gIGNvbnN0IHtzZXJ2aWNlLCByZWxhdGl2ZVBhdGh9ID0gYXdhaXQgY3JlYXRlU2VydmljZShkZXZpY2UudWRpZCwgcmVtb3RlUGF0aCk7XG4gIHRyeSB7XG4gICAgY29uc3QgZmlsZUluZm8gPSBhd2FpdCBzZXJ2aWNlLmdldEZpbGVJbmZvKHJlbGF0aXZlUGF0aCk7XG4gICAgaWYgKGlzRmlsZSAmJiBmaWxlSW5mby5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSByZXF1ZXN0ZWQgcGF0aCBpcyBub3QgYSBmaWxlLiBQYXRoOiAnJHtyZW1vdGVQYXRofSdgKTtcbiAgICB9XG4gICAgaWYgKCFpc0ZpbGUgJiYgIWZpbGVJbmZvLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHJlcXVlc3RlZCBwYXRoIGlzIG5vdCBhIGZvbGRlci4gUGF0aDogJyR7cmVtb3RlUGF0aH0nYCk7XG4gICAgfVxuXG4gICAgaWYgKGZpbGVJbmZvLmlzRmlsZSgpKSB7XG4gICAgICByZXR1cm4gYXdhaXQgcHVsbEZpbGVGcm9tUmVhbERldmljZShzZXJ2aWNlLCByZWxhdGl2ZVBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgcHVsbEZvbGRlckZyb21SZWFsRGV2aWNlKHNlcnZpY2UsIHJlbGF0aXZlUGF0aCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcyhPQkpFQ1RfTk9UX0ZPVU5EX0VSUk9SX01FU1NBR0UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGggJyR7cmVtb3RlUGF0aH0nIGRvZXMgbm90IGV4aXN0IG9uIHRoZSBkZXZpY2VgKTtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXJ2aWNlLmNsb3NlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGZpbGUgb3IgZm9sZGVyIGZyb20gdGhlIGRldmljZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2UgLSBUaGUgZGV2aWNlIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgYHVkaWRgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZGV2aWNlIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcGF0aCB0byBhIGZpbGUgb3IgYSBmb2xkZXIsIHdoaWNoIGV4aXN0cyBpbiB0aGUgY29ycmVzcG9uZGluZyBhcHBsaWNhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgb24gU2ltdWxhdG9yLiBVc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPjo8b3B0aW9uYWxfY29udGFpbmVyX3R5cGU+LzxwYXRoX3RvX3RoZV9maWxlX29yX2ZvbGRlcl9pbnNpZGVfY29udGFpbmVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgdG8gcHVsbCBhIGZpbGUgb3IgYSBmb2xkZXIgZnJvbSBhbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvc3NpYmxlIGNvbnRhaW5lciB0eXBlcyBhcmUgJ2FwcCcsICdkYXRhJywgJ2dyb3VwcycsICc8QSBzcGVjaWZpYyBBcHAgR3JvdXAgY29udGFpbmVyPicuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHR5cGUgaXMgJ2FwcCcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUZyb21TaW11bGF0b3IgKGRldmljZSwgcmVtb3RlUGF0aCkge1xuICBsZXQgcGF0aE9uU2VydmVyO1xuICBpZiAoQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi50ZXN0KHJlbW90ZVBhdGgpKSB7XG4gICAgY29uc3Qge2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXI6IGRzdFBhdGh9ID0gYXdhaXQgcGFyc2VDb250YWluZXJQYXRoKHJlbW90ZVBhdGgsXG4gICAgICBhc3luYyAoYXBwQnVuZGxlLCBjb250YWluZXJUeXBlKSA9PiBhd2FpdCBkZXZpY2Uuc2ltY3RsLmdldEFwcENvbnRhaW5lcihhcHBCdW5kbGUsIGNvbnRhaW5lclR5cGUpKTtcbiAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgYCcke2RzdFBhdGh9JyB3aWxsIGJlIGRlbGV0ZWRgKTtcbiAgICBwYXRoT25TZXJ2ZXIgPSBkc3RQYXRoO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNpbVJvb3QgPSBkZXZpY2UuZ2V0RGlyKCk7XG4gICAgcGF0aE9uU2VydmVyID0gcGF0aC5wb3NpeC5qb2luKHNpbVJvb3QsIHJlbW90ZVBhdGgpO1xuICAgIHZlcmlmeUlzU3ViUGF0aChwYXRoT25TZXJ2ZXIsIHNpbVJvb3QpO1xuICAgIGxvZy5pbmZvKGBHb3QgdGhlIGZ1bGwgcGF0aDogJHtwYXRoT25TZXJ2ZXJ9YCk7XG4gIH1cbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aE9uU2VydmVyKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBUaGUgcmVtb3RlIHBhdGggYXQgJyR7cGF0aE9uU2VydmVyfScgZG9lcyBub3QgZXhpc3RgKTtcbiAgfVxuICBhd2FpdCBmcy5yaW1yYWYocGF0aE9uU2VydmVyKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGZpbGUgb3IgZm9sZGVyIGZyb20gdGhlIGRldmljZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2UgLSBUaGUgZGV2aWNlIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgYHVkaWRgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZGV2aWNlIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcGF0aCB0byBhbiBleGlzdGluZyByZW1vdGUgZmlsZSBvbiB0aGUgZGV2aWNlLiBUaGlzIHZhcmlhYmxlIGNhbiBiZSBwcmVmaXhlZCB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1bmRsZSBpZCwgc28gdGhlbiB0aGUgZmlsZSB3aWxsIGJlIGRvd25sb2FkZWQgZnJvbSB0aGUgY29ycmVzcG9uZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBjb250YWluZXIgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBtZWRpYSBmb2xkZXIuIFVzZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAPGFwcF9idW5kbGVfaWQ+OjxvcHRpb25hbF9jb250YWluZXJfdHlwZT4vPHBhdGhfdG9fdGhlX2ZpbGVfb3JfZm9sZGVyX2luc2lkZV9jb250YWluZXI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCB0byBwdWxsIGEgZmlsZSBvciBhIGZvbGRlciBmcm9tIGFuIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9ubHkgc3VwcG9ydGVkIGNvbnRhaW5lciB0eXBlIGlzICdkb2N1bWVudHMnLiBJZiB0aGUgY29udGFpbmVyIHR5cGUgaXMgbm90IHNldFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBsaWNpdGx5IGZvciBhIGJ1bmRsZSBpZCwgdGhlbiB0aGUgZGVmYXVsdCBhcHBsaWNhdGlvbiBjb250YWluZXIgaXMgZ29pbmcgdG8gYmUgbW91bnRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWthIC0tY29udGFpbmVyIGlmdXNlIGFyZ3VtZW50KVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmcuIElmIGBAY29tLm15YXBwLmJsYTpkb2N1bWVudHMvMTExLnBuZ2AgaXMgcHJvdmlkZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9uIE15IGlQaG9uZS88YXBwIG5hbWU+YCBpbiBGaWxlcyBhcHAgd2lsbCBiZSBtb3VudGVkIGluIHRoZSBob3N0IG1hY2hpbmUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9uIE15IGlQaG9uZS88YXBwIG5hbWU+LzExMS5wbmdgIHdpbCBiZSBwdWxsZWQgaW50byB0aGUgbW91bnRlZCBob3N0IG1hY2hpbmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgQXBwaXVtIHJldHVybnMgdGhlIGRhdGEgYXMgYmFzZTY0LWVuY29kZWQgc3RyaW5nIHRvIGNsaWVudC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgQGNvbS5teWFwcC5ibGE6ZG9jdW1lbnRzL2AgbWVhbnMgYE9uIE15IGlQaG9uZS88YXBwIG5hbWU+YC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlRnJvbVJlYWxEZXZpY2UgKGRldmljZSwgcmVtb3RlUGF0aCkge1xuICBjb25zdCB7IHNlcnZpY2UsIHJlbGF0aXZlUGF0aCB9ID0gYXdhaXQgY3JlYXRlU2VydmljZShkZXZpY2UudWRpZCwgcmVtb3RlUGF0aCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgc2VydmljZS5kZWxldGVEaXJlY3RvcnkocmVsYXRpdmVQYXRoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLm1lc3NhZ2UuaW5jbHVkZXMoT0JKRUNUX05PVF9GT1VORF9FUlJPUl9NRVNTQUdFKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXRoICcke3JlbW90ZVBhdGh9JyBkb2VzIG5vdCBleGlzdCBvbiB0aGUgZGV2aWNlYCk7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH0gZmluYWxseSB7XG4gICAgc2VydmljZS5jbG9zZSgpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGJ1bmRsZUlkcyB3aGljaCBjYW4gbW91bnQgYnkgYC0tZG9jdW1lbnRzYCBmbGFnXG4gKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB1ZGlkIC0gVGhlIHVkaWQgb2YgdGhlIHRhcmdldCBkZXZpY2VcbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBBIGxpc3Qgb2YgVXNlciBsZXZlbCBhcHBzJyBidW5kbGUgaWRzIHdoaWNoIGhhc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICdVSUZpbGVTaGFyaW5nRW5hYmxlZCcgYXR0cmlidXRlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgdXNlciBhcHBzIG1pZ2h0IGhhdmUgaXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEF2YWlsYWJsZUJ1bmRsZUlkcyAodWRpZCkge1xuICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgc2VydmljZXMuc3RhcnRJbnN0YWxsYXRpb25Qcm94eVNlcnZpY2UodWRpZCk7XG4gIHRyeSB7XG4gICAgY29uc3QgYXBwbGljYXRpb25zID0gYXdhaXQgc2VydmljZS5saXN0QXBwbGljYXRpb25zKHthcHBsaWNhdGlvblR5cGU6ICdVc2VyJ30pO1xuICAgIGNvbnN0IGJ1bmRsZUlkcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFwcGxpY2F0aW9ucykpIHtcbiAgICAgIGlmICghdmFsdWUuVUlGaWxlU2hhcmluZ0VuYWJsZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBidW5kbGVJZHMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVuZGxlSWRzO1xuICB9IGZpbmFsbHkge1xuICAgIHNlcnZpY2UuY2xvc2UoKTtcbiAgfVxufVxuXG5cbmNvbW1hbmRzLnB1c2hGaWxlID0gYXN5bmMgZnVuY3Rpb24gcHVzaEZpbGUgKHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpIHtcbiAgaWYgKHJlbW90ZVBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBJdCBpcyBleHBlY3RlZCB0aGF0IHJlbW90ZSBwYXRoIHBvaW50cyB0byBhIGZpbGUgYW5kIG5vdCB0byBhIGZvbGRlci4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCcke3JlbW90ZVBhdGh9JyBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgaWYgKF8uaXNBcnJheShiYXNlNjREYXRhKSkge1xuICAgIC8vIHNvbWUgY2xpZW50cyAoYWhlbSkgamF2YSwgc2VuZCBhIGJ5dGUgYXJyYXkgZW5jb2RpbmcgdXRmOCBjaGFyYWN0ZXJzXG4gICAgLy8gaW5zdGVhZCBvZiBhIHN0cmluZywgd2hpY2ggd291bGQgYmUgaW5maW5pdGVseSBiZXR0ZXIhXG4gICAgYmFzZTY0RGF0YSA9IEJ1ZmZlci5mcm9tKGJhc2U2NERhdGEpLnRvU3RyaW5nKCd1dGY4Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaXNTaW11bGF0b3IoKVxuICAgID8gYXdhaXQgcHVzaEZpbGVUb1NpbXVsYXRvcih0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKVxuICAgIDogYXdhaXQgcHVzaEZpbGVUb1JlYWxEZXZpY2UodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgYmFzZTY0RGF0YSk7XG59O1xuXG5jb21tYW5kcy5wdWxsRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIHB1bGxGaWxlIChyZW1vdGVQYXRoKSB7XG4gIGlmIChyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSXQgaXMgZXhwZWN0ZWQgdGhhdCByZW1vdGUgcGF0aCBwb2ludHMgdG8gYSBmaWxlIGFuZCBub3QgdG8gYSBmb2xkZXIuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGAnJHtyZW1vdGVQYXRofScgaXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIHJldHVybiB0aGlzLmlzU2ltdWxhdG9yKClcbiAgICA/IGF3YWl0IHB1bGxGcm9tU2ltdWxhdG9yKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIHRydWUpXG4gICAgOiBhd2FpdCBwdWxsRnJvbVJlYWxEZXZpY2UodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgdHJ1ZSk7XG59O1xuXG5hc3luYyBmdW5jdGlvbiBkZWxldGVGaWxlT3JGb2xkZXIgKGRldmljZSwgcmVtb3RlUGF0aCwgaXNTaW11bGF0b3IpIHtcbiAgcmV0dXJuIGlzU2ltdWxhdG9yXG4gICAgPyBhd2FpdCBkZWxldGVGcm9tU2ltdWxhdG9yKGRldmljZSwgcmVtb3RlUGF0aClcbiAgICA6IGF3YWl0IGRlbGV0ZUZyb21SZWFsRGV2aWNlKGRldmljZSwgcmVtb3RlUGF0aCk7XG59XG5cbmNvbW1hbmRzLm1vYmlsZURlbGV0ZUZvbGRlciA9IGFzeW5jIGZ1bmN0aW9uIG1vYmlsZURlbGV0ZUZvbGRlciAob3B0cyA9IHt9KSB7XG4gIGxldCB7cmVtb3RlUGF0aH0gPSBvcHRzO1xuICBpZiAoIXJlbW90ZVBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgIHJlbW90ZVBhdGggPSBgJHtyZW1vdGVQYXRofS9gO1xuICB9XG4gIHJldHVybiBhd2FpdCBkZWxldGVGaWxlT3JGb2xkZXIodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgdGhpcy5pc1NpbXVsYXRvcigpKTtcbn07XG5cbmNvbW1hbmRzLm1vYmlsZURlbGV0ZUZpbGUgPSBhc3luYyBmdW5jdGlvbiBtb2JpbGVEZWxldGVGaWxlIChvcHRzID0ge30pIHtcbiAgY29uc3Qge3JlbW90ZVBhdGh9ID0gb3B0cztcbiAgaWYgKHJlbW90ZVBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBJdCBpcyBleHBlY3RlZCB0aGF0IHJlbW90ZSBwYXRoIHBvaW50cyB0byBhIGZpbGUgYW5kIG5vdCB0byBhIGZvbGRlci4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCcke3JlbW90ZVBhdGh9JyBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGRlbGV0ZUZpbGVPckZvbGRlcih0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCB0aGlzLmlzU2ltdWxhdG9yKCkpO1xufTtcblxuY29tbWFuZHMuZ2V0U2ltRmlsZUZ1bGxQYXRoID0gYXN5bmMgZnVuY3Rpb24gZ2V0U2ltRmlsZUZ1bGxQYXRoIChyZW1vdGVQYXRoKSB7XG4gIGxldCBiYXNlUGF0aCA9IHRoaXMub3B0cy5kZXZpY2UuZ2V0RGlyKCk7XG4gIGxldCBhcHBOYW1lID0gbnVsbDtcblxuICBpZiAodGhpcy5vcHRzLmFwcCkge1xuICAgIGxldCBhcHBOYW1lUmVnZXggPSBuZXcgUmVnRXhwKGBcXFxcJHtwYXRoLnNlcH0oW1xcXFx3LV0rXFxcXC5hcHApYCk7XG4gICAgbGV0IGFwcE5hbWVNYXRjaGVzID0gYXBwTmFtZVJlZ2V4LmV4ZWModGhpcy5vcHRzLmFwcCk7XG4gICAgaWYgKGFwcE5hbWVNYXRjaGVzKSB7XG4gICAgICBhcHBOYW1lID0gYXBwTmFtZU1hdGNoZXNbMV07XG4gICAgfVxuICB9XG4gIC8vIGRlLWFic29sdXRpemUgdGhlIHBhdGhcbiAgaWYgKHN5c3RlbS5pc1dpbmRvd3MoKSkge1xuICAgIGlmIChyZW1vdGVQYXRoLmluZGV4b2YoJzovLycpID09PSAxKSB7XG4gICAgICByZW1vdGVQYXRoID0gcmVtb3RlUGF0aC5zbGljZSg0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJlbW90ZVBhdGguaW5kZXhPZignLycpID09PSAwKSB7XG4gICAgICByZW1vdGVQYXRoID0gcmVtb3RlUGF0aC5zbGljZSgxKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVtb3RlUGF0aC5zdGFydHNXaXRoKGFwcE5hbWUpKSB7XG4gICAgbGV0IGZpbmRQYXRoID0gYmFzZVBhdGg7XG4gICAgaWYgKCF0aGlzLm9wdHMucGxhdGZvcm1WZXJzaW9uIHx8IHV0aWwuY29tcGFyZVZlcnNpb25zKHRoaXMub3B0cy5wbGF0Zm9ybVZlcnNpb24sICc+PScsICc4LjAnKSkge1xuICAgICAgLy8gdGhlIC5hcHAgZmlsZSBhcHBlYXJzIGluIC9Db250YWluZXJzL0RhdGEgYW5kIC9Db250YWluZXJzL0J1bmRsZSBib3RoLiBXZSBvbmx5IHdhbnQgL0J1bmRsZVxuICAgICAgZmluZFBhdGggPSBwYXRoLnJlc29sdmUoYmFzZVBhdGgsICdDb250YWluZXJzJywgJ0J1bmRsZScpO1xuICAgIH1cbiAgICBmaW5kUGF0aCA9IGZpbmRQYXRoLnJlcGxhY2UoL1xccy9nLCAnXFxcXCAnKTtcblxuICAgIGxldCB7IHN0ZG91dCB9ID0gYXdhaXQgZXhlYygnZmluZCcsIFtmaW5kUGF0aCwgJy1uYW1lJywgYXBwTmFtZV0pO1xuICAgIGxldCBhcHBSb290ID0gc3Rkb3V0LnJlcGxhY2UoL1xcbiQvLCAnJyk7XG4gICAgbGV0IHN1YlBhdGggPSByZW1vdGVQYXRoLnN1YnN0cmluZyhhcHBOYW1lLmxlbmd0aCArIDEpO1xuICAgIGxldCBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZShhcHBSb290LCBzdWJQYXRoKTtcbiAgICBsb2cuZGVidWcoYEZpbmRpbmcgYXBwLXJlbGF0aXZlIGZpbGU6ICcke2Z1bGxQYXRofSdgKTtcbiAgICByZXR1cm4gZnVsbFBhdGg7XG4gIH1cblxuICBsZXQgZnVsbFBhdGggPSBwYXRoLnJlc29sdmUoYmFzZVBhdGgsIHJlbW90ZVBhdGgpO1xuICBsb2cuZGVidWcoYEZpbmRpbmcgc2ltLXJlbGF0aXZlIGZpbGU6ICR7ZnVsbFBhdGh9YCk7XG4gIHJldHVybiBmdWxsUGF0aDtcbn07XG5cbmNvbW1hbmRzLnB1bGxGb2xkZXIgPSBhc3luYyBmdW5jdGlvbiBwdWxsRm9sZGVyIChyZW1vdGVQYXRoKSB7XG4gIGlmICghcmVtb3RlUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgcmVtb3RlUGF0aCA9IGAke3JlbW90ZVBhdGh9L2A7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaXNTaW11bGF0b3IoKVxuICAgID8gYXdhaXQgcHVsbEZyb21TaW11bGF0b3IodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgZmFsc2UpXG4gICAgOiBhd2FpdCBwdWxsRnJvbVJlYWxEZXZpY2UodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgZmFsc2UpO1xufTtcblxuZXhwb3J0IHsgY29tbWFuZHMsIC8qIGZvciB0ZXN0aW5nICovIGdldEF2YWlsYWJsZUJ1bmRsZUlkcyxcbiAgLyogZm9yIHRlc3RpbmcgKi8gcGFyc2VDb250YWluZXJQYXRoIH07XG5leHBvcnQgZGVmYXVsdCBjb21tYW5kcztcbiJdLCJmaWxlIjoibGliL2NvbW1hbmRzL2ZpbGUtbW92ZW1lbnQuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
