"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _logger = _interopRequireDefault(require("./logger"));

var _remoteDebugger = require("./remote-debugger");

var _helpers = require("./helpers");

var _lodash = _interopRequireDefault(require("lodash"));

async function onPageChange(err, appIdKey, pageDict) {
  if (_lodash.default.isEmpty(pageDict)) {
    return;
  }

  const pageArray = (0, _helpers.pageArrayFromDict)(pageDict);
  await this.useAppDictLock(done => {
    try {
      if (this.appDict[appIdKey]) {
        if (this.appDict[appIdKey].pageArray) {
          if (this.appDict[appIdKey].pageArray.resolve) {
            this.appDict[appIdKey].pageArray.resolve();
          } else {
            if (_lodash.default.isEqual(this.appDict[appIdKey].pageArray, pageArray)) {
              _logger.default.debug(`Received page change notice for app '${appIdKey}' ` + `but the listing has not changed. Ignoring.`);

              return done();
            }
          }
        }

        this.appDict[appIdKey].pageArray = pageArray;
      }
    } finally {
      done();
    }
  });

  if (this._navigatingToPage) {
    return;
  }

  _logger.default.debug(`Page changed: ${(0, _helpers.simpleStringify)(pageDict, true)}`);

  this.emit(_remoteDebugger.RemoteDebugger.EVENT_PAGE_CHANGE, {
    appIdKey: appIdKey.replace('PID:', ''),
    pageArray
  });
}

async function onAppConnect(err, dict) {
  let appIdKey = dict.WIRApplicationIdentifierKey;

  _logger.default.debug(`Notified that new application '${appIdKey}' has connected`);

  await this.useAppDictLock(done => {
    try {
      this.updateAppsWithDict(dict);
    } finally {
      done();
    }
  });
}

function onAppDisconnect(err, dict) {
  let appIdKey = dict.WIRApplicationIdentifierKey;

  _logger.default.debug(`Application '${appIdKey}' disconnected. Removing from app dictionary.`);

  _logger.default.debug(`Current app is '${this.appIdKey}'`);

  delete this.appDict[appIdKey];

  if (this.appIdKey === appIdKey) {
    _logger.default.debug(`No longer have app id. Attempting to find new one.`);

    this.appIdKey = (0, _helpers.getDebuggerAppKey)(this.bundleId, this.appDict);
  }

  if (!this.appDict) {
    _logger.default.debug('Main app disconnected. Disconnecting altogether.');

    this.connected = false;
    this.emit(_remoteDebugger.RemoteDebugger.EVENT_DISCONNECT, true);
  }
}

async function onAppUpdate(err, dict) {
  await this.useAppDictLock(done => {
    try {
      this.updateAppsWithDict(dict);
    } finally {
      done();
    }
  });
}

function onConnectedDriverList(err, drivers) {
  this.connectedDrivers = drivers.WIRDriverDictionaryKey;

  _logger.default.debug(`Received connected driver list: ${JSON.stringify(this.connectedDrivers)}`);
}

async function onConnectedApplicationList(err, apps) {
  _logger.default.debug(`Received connected applications list: ${_lodash.default.keys(apps).join(', ')}`);

  let newDict = {};

  for (const dict of _lodash.default.values(apps)) {
    const [id, entry] = (0, _helpers.appInfoFromDict)(dict);

    if (this.skippedApps.includes(entry.name)) {
      continue;
    }

    newDict[id] = entry;
  }

  await this.useAppDictLock(done => {
    try {
      _lodash.default.defaults(this.appDict, newDict);
    } finally {
      done();
    }
  });
}

const messageHandlers = {
  onPageChange,
  onAppConnect,
  onAppDisconnect,
  onAppUpdate,
  onConnectedDriverList,
  onConnectedApplicationList
};
var _default = messageHandlers;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9tZXNzYWdlLWhhbmRsZXJzLmpzIl0sIm5hbWVzIjpbIm9uUGFnZUNoYW5nZSIsImVyciIsImFwcElkS2V5IiwicGFnZURpY3QiLCJfIiwiaXNFbXB0eSIsInBhZ2VBcnJheSIsInVzZUFwcERpY3RMb2NrIiwiZG9uZSIsImFwcERpY3QiLCJyZXNvbHZlIiwiaXNFcXVhbCIsImxvZyIsImRlYnVnIiwiX25hdmlnYXRpbmdUb1BhZ2UiLCJlbWl0IiwiUmVtb3RlRGVidWdnZXIiLCJFVkVOVF9QQUdFX0NIQU5HRSIsInJlcGxhY2UiLCJvbkFwcENvbm5lY3QiLCJkaWN0IiwiV0lSQXBwbGljYXRpb25JZGVudGlmaWVyS2V5IiwidXBkYXRlQXBwc1dpdGhEaWN0Iiwib25BcHBEaXNjb25uZWN0IiwiYnVuZGxlSWQiLCJjb25uZWN0ZWQiLCJFVkVOVF9ESVNDT05ORUNUIiwib25BcHBVcGRhdGUiLCJvbkNvbm5lY3RlZERyaXZlckxpc3QiLCJkcml2ZXJzIiwiY29ubmVjdGVkRHJpdmVycyIsIldJUkRyaXZlckRpY3Rpb25hcnlLZXkiLCJKU09OIiwic3RyaW5naWZ5Iiwib25Db25uZWN0ZWRBcHBsaWNhdGlvbkxpc3QiLCJhcHBzIiwia2V5cyIsImpvaW4iLCJuZXdEaWN0IiwidmFsdWVzIiwiaWQiLCJlbnRyeSIsInNraXBwZWRBcHBzIiwiaW5jbHVkZXMiLCJuYW1lIiwiZGVmYXVsdHMiLCJtZXNzYWdlSGFuZGxlcnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBUUEsZUFBZUEsWUFBZixDQUE2QkMsR0FBN0IsRUFBa0NDLFFBQWxDLEVBQTRDQyxRQUE1QyxFQUFzRDtBQUNwRCxNQUFJQyxnQkFBRUMsT0FBRixDQUFVRixRQUFWLENBQUosRUFBeUI7QUFDdkI7QUFDRDs7QUFFRCxRQUFNRyxTQUFTLEdBQUcsZ0NBQWtCSCxRQUFsQixDQUFsQjtBQUVBLFFBQU0sS0FBS0ksY0FBTCxDQUFxQkMsSUFBRCxJQUFVO0FBQ2xDLFFBQUk7QUFFRixVQUFJLEtBQUtDLE9BQUwsQ0FBYVAsUUFBYixDQUFKLEVBQTRCO0FBQzFCLFlBQUksS0FBS08sT0FBTCxDQUFhUCxRQUFiLEVBQXVCSSxTQUEzQixFQUFzQztBQUNwQyxjQUFJLEtBQUtHLE9BQUwsQ0FBYVAsUUFBYixFQUF1QkksU0FBdkIsQ0FBaUNJLE9BQXJDLEVBQThDO0FBRTVDLGlCQUFLRCxPQUFMLENBQWFQLFFBQWIsRUFBdUJJLFNBQXZCLENBQWlDSSxPQUFqQztBQUNELFdBSEQsTUFHTztBQUVMLGdCQUFJTixnQkFBRU8sT0FBRixDQUFVLEtBQUtGLE9BQUwsQ0FBYVAsUUFBYixFQUF1QkksU0FBakMsRUFBNENBLFNBQTVDLENBQUosRUFBNEQ7QUFDMURNLDhCQUFJQyxLQUFKLENBQVcsd0NBQXVDWCxRQUFTLElBQWpELEdBQ0MsNENBRFg7O0FBRUEscUJBQU9NLElBQUksRUFBWDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxhQUFLQyxPQUFMLENBQWFQLFFBQWIsRUFBdUJJLFNBQXZCLEdBQW1DQSxTQUFuQztBQUNEO0FBQ0YsS0FuQkQsU0FtQlU7QUFDUkUsTUFBQUEsSUFBSTtBQUNMO0FBQ0YsR0F2QkssQ0FBTjs7QUF5QkEsTUFBSSxLQUFLTSxpQkFBVCxFQUE0QjtBQUUxQjtBQUNEOztBQUVERixrQkFBSUMsS0FBSixDQUFXLGlCQUFnQiw4QkFBZ0JWLFFBQWhCLEVBQTBCLElBQTFCLENBQWdDLEVBQTNEOztBQUVBLE9BQUtZLElBQUwsQ0FBVUMsK0JBQWVDLGlCQUF6QixFQUE0QztBQUMxQ2YsSUFBQUEsUUFBUSxFQUFFQSxRQUFRLENBQUNnQixPQUFULENBQWlCLE1BQWpCLEVBQXlCLEVBQXpCLENBRGdDO0FBRTFDWixJQUFBQTtBQUYwQyxHQUE1QztBQUlEOztBQUVELGVBQWVhLFlBQWYsQ0FBNkJsQixHQUE3QixFQUFrQ21CLElBQWxDLEVBQXdDO0FBQ3RDLE1BQUlsQixRQUFRLEdBQUdrQixJQUFJLENBQUNDLDJCQUFwQjs7QUFDQVQsa0JBQUlDLEtBQUosQ0FBVyxrQ0FBaUNYLFFBQVMsaUJBQXJEOztBQUNBLFFBQU0sS0FBS0ssY0FBTCxDQUFxQkMsSUFBRCxJQUFVO0FBQ2xDLFFBQUk7QUFDRixXQUFLYyxrQkFBTCxDQUF3QkYsSUFBeEI7QUFDRCxLQUZELFNBRVU7QUFDUlosTUFBQUEsSUFBSTtBQUNMO0FBQ0YsR0FOSyxDQUFOO0FBT0Q7O0FBRUQsU0FBU2UsZUFBVCxDQUEwQnRCLEdBQTFCLEVBQStCbUIsSUFBL0IsRUFBcUM7QUFDbkMsTUFBSWxCLFFBQVEsR0FBR2tCLElBQUksQ0FBQ0MsMkJBQXBCOztBQUNBVCxrQkFBSUMsS0FBSixDQUFXLGdCQUFlWCxRQUFTLCtDQUFuQzs7QUFDQVUsa0JBQUlDLEtBQUosQ0FBVyxtQkFBa0IsS0FBS1gsUUFBUyxHQUEzQzs7QUFJQSxTQUFPLEtBQUtPLE9BQUwsQ0FBYVAsUUFBYixDQUFQOztBQUdBLE1BQUksS0FBS0EsUUFBTCxLQUFrQkEsUUFBdEIsRUFBZ0M7QUFDOUJVLG9CQUFJQyxLQUFKLENBQVcsb0RBQVg7O0FBQ0EsU0FBS1gsUUFBTCxHQUFnQixnQ0FBa0IsS0FBS3NCLFFBQXZCLEVBQWlDLEtBQUtmLE9BQXRDLENBQWhCO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDLEtBQUtBLE9BQVYsRUFBbUI7QUFFakJHLG9CQUFJQyxLQUFKLENBQVUsa0RBQVY7O0FBQ0EsU0FBS1ksU0FBTCxHQUFpQixLQUFqQjtBQUNBLFNBQUtWLElBQUwsQ0FBVUMsK0JBQWVVLGdCQUF6QixFQUEyQyxJQUEzQztBQUNEO0FBQ0Y7O0FBRUQsZUFBZUMsV0FBZixDQUE0QjFCLEdBQTVCLEVBQWlDbUIsSUFBakMsRUFBdUM7QUFDckMsUUFBTSxLQUFLYixjQUFMLENBQXFCQyxJQUFELElBQVU7QUFDbEMsUUFBSTtBQUNGLFdBQUtjLGtCQUFMLENBQXdCRixJQUF4QjtBQUNELEtBRkQsU0FFVTtBQUNSWixNQUFBQSxJQUFJO0FBQ0w7QUFDRixHQU5LLENBQU47QUFPRDs7QUFFRCxTQUFTb0IscUJBQVQsQ0FBZ0MzQixHQUFoQyxFQUFxQzRCLE9BQXJDLEVBQThDO0FBQzVDLE9BQUtDLGdCQUFMLEdBQXdCRCxPQUFPLENBQUNFLHNCQUFoQzs7QUFDQW5CLGtCQUFJQyxLQUFKLENBQVcsbUNBQWtDbUIsSUFBSSxDQUFDQyxTQUFMLENBQWUsS0FBS0gsZ0JBQXBCLENBQXNDLEVBQW5GO0FBQ0Q7O0FBRUQsZUFBZUksMEJBQWYsQ0FBMkNqQyxHQUEzQyxFQUFnRGtDLElBQWhELEVBQXNEO0FBQ3BEdkIsa0JBQUlDLEtBQUosQ0FBVyx5Q0FBd0NULGdCQUFFZ0MsSUFBRixDQUFPRCxJQUFQLEVBQWFFLElBQWIsQ0FBa0IsSUFBbEIsQ0FBd0IsRUFBM0U7O0FBSUEsTUFBSUMsT0FBTyxHQUFHLEVBQWQ7O0FBQ0EsT0FBSyxNQUFNbEIsSUFBWCxJQUFtQmhCLGdCQUFFbUMsTUFBRixDQUFTSixJQUFULENBQW5CLEVBQW1DO0FBQ2pDLFVBQU0sQ0FBQ0ssRUFBRCxFQUFLQyxLQUFMLElBQWMsOEJBQWdCckIsSUFBaEIsQ0FBcEI7O0FBQ0EsUUFBSSxLQUFLc0IsV0FBTCxDQUFpQkMsUUFBakIsQ0FBMEJGLEtBQUssQ0FBQ0csSUFBaEMsQ0FBSixFQUEyQztBQUN6QztBQUNEOztBQUNETixJQUFBQSxPQUFPLENBQUNFLEVBQUQsQ0FBUCxHQUFjQyxLQUFkO0FBQ0Q7O0FBRUQsUUFBTSxLQUFLbEMsY0FBTCxDQUFxQkMsSUFBRCxJQUFVO0FBQ2xDLFFBQUk7QUFDRkosc0JBQUV5QyxRQUFGLENBQVcsS0FBS3BDLE9BQWhCLEVBQXlCNkIsT0FBekI7QUFDRCxLQUZELFNBRVU7QUFDUjlCLE1BQUFBLElBQUk7QUFDTDtBQUNGLEdBTkssQ0FBTjtBQU9EOztBQUVELE1BQU1zQyxlQUFlLEdBQUc7QUFDdEI5QyxFQUFBQSxZQURzQjtBQUV0Qm1CLEVBQUFBLFlBRnNCO0FBR3RCSSxFQUFBQSxlQUhzQjtBQUl0QkksRUFBQUEsV0FKc0I7QUFLdEJDLEVBQUFBLHFCQUxzQjtBQU10Qk0sRUFBQUE7QUFOc0IsQ0FBeEI7ZUFTZVksZSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgUmVtb3RlRGVidWdnZXIgfSBmcm9tICcuL3JlbW90ZS1kZWJ1Z2dlcic7XG5pbXBvcnQgeyBwYWdlQXJyYXlGcm9tRGljdCwgZ2V0RGVidWdnZXJBcHBLZXksIHNpbXBsZVN0cmluZ2lmeSwgYXBwSW5mb0Zyb21EaWN0IH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cblxuLypcbiAqIEdlbmVyaWMgY2FsbGJhY2tzIHVzZWQgdGhyb3VnaG91dCB0aGUgbGlmZWN5Y2xlIG9mIHRoZSBSZW1vdGUgRGVidWdnZXIuXG4gKiBUaGVzZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBwcm90b3R5cGUuXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gb25QYWdlQ2hhbmdlIChlcnIsIGFwcElkS2V5LCBwYWdlRGljdCkge1xuICBpZiAoXy5pc0VtcHR5KHBhZ2VEaWN0KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBhZ2VBcnJheSA9IHBhZ2VBcnJheUZyb21EaWN0KHBhZ2VEaWN0KTtcblxuICBhd2FpdCB0aGlzLnVzZUFwcERpY3RMb2NrKChkb25lKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIHNhdmUgdGhlIHBhZ2UgZGljdCBmb3IgdGhpcyBhcHBcbiAgICAgIGlmICh0aGlzLmFwcERpY3RbYXBwSWRLZXldKSB7XG4gICAgICAgIGlmICh0aGlzLmFwcERpY3RbYXBwSWRLZXldLnBhZ2VBcnJheSkge1xuICAgICAgICAgIGlmICh0aGlzLmFwcERpY3RbYXBwSWRLZXldLnBhZ2VBcnJheS5yZXNvbHZlKSB7XG4gICAgICAgICAgICAvLyBwYWdlRGljdCBpcyBhIHBlbmRpbmcgcHJvbWlzZSwgc28gcmVzb2x2ZVxuICAgICAgICAgICAgdGhpcy5hcHBEaWN0W2FwcElkS2V5XS5wYWdlQXJyYXkucmVzb2x2ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGEgcHJlLWV4aXN0aW5nIHBhZ2VEaWN0XG4gICAgICAgICAgICBpZiAoXy5pc0VxdWFsKHRoaXMuYXBwRGljdFthcHBJZEtleV0ucGFnZUFycmF5LCBwYWdlQXJyYXkpKSB7XG4gICAgICAgICAgICAgIGxvZy5kZWJ1ZyhgUmVjZWl2ZWQgcGFnZSBjaGFuZ2Ugbm90aWNlIGZvciBhcHAgJyR7YXBwSWRLZXl9JyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBidXQgdGhlIGxpc3RpbmcgaGFzIG5vdCBjaGFuZ2VkLiBJZ25vcmluZy5gKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgcGFnZSBkaWN0aW9uYXJ5XG4gICAgICAgIHRoaXMuYXBwRGljdFthcHBJZEtleV0ucGFnZUFycmF5ID0gcGFnZUFycmF5O1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9KTtcblxuICBpZiAodGhpcy5fbmF2aWdhdGluZ1RvUGFnZSkge1xuICAgIC8vIGluIHRoZSBtaWRkbGUgb2YgbmF2aWdhdGluZywgc28gcmVwb3J0aW5nIGEgcGFnZSBjaGFuZ2Ugd2lsbCBjYXVzZSBwcm9ibGVtc1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZyhgUGFnZSBjaGFuZ2VkOiAke3NpbXBsZVN0cmluZ2lmeShwYWdlRGljdCwgdHJ1ZSl9YCk7XG5cbiAgdGhpcy5lbWl0KFJlbW90ZURlYnVnZ2VyLkVWRU5UX1BBR0VfQ0hBTkdFLCB7XG4gICAgYXBwSWRLZXk6IGFwcElkS2V5LnJlcGxhY2UoJ1BJRDonLCAnJyksXG4gICAgcGFnZUFycmF5LFxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gb25BcHBDb25uZWN0IChlcnIsIGRpY3QpIHtcbiAgbGV0IGFwcElkS2V5ID0gZGljdC5XSVJBcHBsaWNhdGlvbklkZW50aWZpZXJLZXk7XG4gIGxvZy5kZWJ1ZyhgTm90aWZpZWQgdGhhdCBuZXcgYXBwbGljYXRpb24gJyR7YXBwSWRLZXl9JyBoYXMgY29ubmVjdGVkYCk7XG4gIGF3YWl0IHRoaXMudXNlQXBwRGljdExvY2soKGRvbmUpID0+IHtcbiAgICB0cnkge1xuICAgICAgdGhpcy51cGRhdGVBcHBzV2l0aERpY3QoZGljdCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvbkFwcERpc2Nvbm5lY3QgKGVyciwgZGljdCkge1xuICBsZXQgYXBwSWRLZXkgPSBkaWN0LldJUkFwcGxpY2F0aW9uSWRlbnRpZmllcktleTtcbiAgbG9nLmRlYnVnKGBBcHBsaWNhdGlvbiAnJHthcHBJZEtleX0nIGRpc2Nvbm5lY3RlZC4gUmVtb3ZpbmcgZnJvbSBhcHAgZGljdGlvbmFyeS5gKTtcbiAgbG9nLmRlYnVnKGBDdXJyZW50IGFwcCBpcyAnJHt0aGlzLmFwcElkS2V5fSdgKTtcblxuICAvLyBnZXQgcmlkIG9mIHRoZSBlbnRyeSBpbiBvdXIgYXBwIGRpY3Rpb25hcnksXG4gIC8vIHNpbmNlIGl0IGlzIG5vIGxvbmdlciBhdmFpbGFibGVcbiAgZGVsZXRlIHRoaXMuYXBwRGljdFthcHBJZEtleV07XG5cbiAgLy8gaWYgdGhlIGRpc2Nvbm5lY3RlZCBhcHAgaXMgdGhlIG9uZSB3ZSBhcmUgY29ubmVjdGVkIHRvLCB0cnkgdG8gZmluZCBhbm90aGVyXG4gIGlmICh0aGlzLmFwcElkS2V5ID09PSBhcHBJZEtleSkge1xuICAgIGxvZy5kZWJ1ZyhgTm8gbG9uZ2VyIGhhdmUgYXBwIGlkLiBBdHRlbXB0aW5nIHRvIGZpbmQgbmV3IG9uZS5gKTtcbiAgICB0aGlzLmFwcElkS2V5ID0gZ2V0RGVidWdnZXJBcHBLZXkodGhpcy5idW5kbGVJZCwgdGhpcy5hcHBEaWN0KTtcbiAgfVxuXG4gIGlmICghdGhpcy5hcHBEaWN0KSB7XG4gICAgLy8gdGhpcyBtZWFucyB3ZSBubyBsb25nZXIgaGF2ZSBhbnkgYXBwcy4gd2hhdCB0aGUgd2hhdD9cbiAgICBsb2cuZGVidWcoJ01haW4gYXBwIGRpc2Nvbm5lY3RlZC4gRGlzY29ubmVjdGluZyBhbHRvZ2V0aGVyLicpO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KFJlbW90ZURlYnVnZ2VyLkVWRU5UX0RJU0NPTk5FQ1QsIHRydWUpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uQXBwVXBkYXRlIChlcnIsIGRpY3QpIHtcbiAgYXdhaXQgdGhpcy51c2VBcHBEaWN0TG9jaygoZG9uZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnVwZGF0ZUFwcHNXaXRoRGljdChkaWN0KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uQ29ubmVjdGVkRHJpdmVyTGlzdCAoZXJyLCBkcml2ZXJzKSB7XG4gIHRoaXMuY29ubmVjdGVkRHJpdmVycyA9IGRyaXZlcnMuV0lSRHJpdmVyRGljdGlvbmFyeUtleTtcbiAgbG9nLmRlYnVnKGBSZWNlaXZlZCBjb25uZWN0ZWQgZHJpdmVyIGxpc3Q6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5jb25uZWN0ZWREcml2ZXJzKX1gKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gb25Db25uZWN0ZWRBcHBsaWNhdGlvbkxpc3QgKGVyciwgYXBwcykge1xuICBsb2cuZGVidWcoYFJlY2VpdmVkIGNvbm5lY3RlZCBhcHBsaWNhdGlvbnMgbGlzdDogJHtfLmtleXMoYXBwcykuam9pbignLCAnKX1gKTtcblxuICAvLyB0cmFuc2xhdGUgdGhlIHJlY2VpdmVkIGluZm9ybWF0aW9uIGludG8gYW4gZWFzaWVyLXRvLW1hbmFnZVxuICAvLyBoYXNoIHdpdGggYXBwIGlkIGFzIGtleSwgYW5kIGFwcCBpbmZvIGFzIHZhbHVlXG4gIGxldCBuZXdEaWN0ID0ge307XG4gIGZvciAoY29uc3QgZGljdCBvZiBfLnZhbHVlcyhhcHBzKSkge1xuICAgIGNvbnN0IFtpZCwgZW50cnldID0gYXBwSW5mb0Zyb21EaWN0KGRpY3QpO1xuICAgIGlmICh0aGlzLnNraXBwZWRBcHBzLmluY2x1ZGVzKGVudHJ5Lm5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbmV3RGljdFtpZF0gPSBlbnRyeTtcbiAgfVxuICAvLyB1cGRhdGUgdGhlIG9iamVjdCdzIGxpc3Qgb2YgYXBwc1xuICBhd2FpdCB0aGlzLnVzZUFwcERpY3RMb2NrKChkb25lKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIF8uZGVmYXVsdHModGhpcy5hcHBEaWN0LCBuZXdEaWN0KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IG1lc3NhZ2VIYW5kbGVycyA9IHtcbiAgb25QYWdlQ2hhbmdlLFxuICBvbkFwcENvbm5lY3QsXG4gIG9uQXBwRGlzY29ubmVjdCxcbiAgb25BcHBVcGRhdGUsXG4gIG9uQ29ubmVjdGVkRHJpdmVyTGlzdCxcbiAgb25Db25uZWN0ZWRBcHBsaWNhdGlvbkxpc3QsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBtZXNzYWdlSGFuZGxlcnM7XG4iXSwiZmlsZSI6ImxpYi9tZXNzYWdlLWhhbmRsZXJzLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
